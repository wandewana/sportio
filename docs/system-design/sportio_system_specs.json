{
  "system_design": {
    "metadata": {
      "document_name": "Sportio Backend System Design",
      "version": "1.0",
      "created_date": "2025-11-29",
      "format": "AI-Agent Friendly JSON Specification"
    },
    "technology_stack": {
      "backend_framework": "Spring WebFlux (Reactive)",
      "database": "PostgreSQL with R2DBC",
      "real_time": "WebSocket with Spring WebFlux",
      "message_queue": "Redis Pub/Sub for real-time events",
      "cache": "Redis for session/geo-queries",
      "payment": "Stripe API",
      "push_notifications": "FCM/APNs",
      "email": "SendGrid"
    },
    "entity_relationship_diagram": {
      "entities": {
        "users": {
          "primary_key": "id",
          "fields": [
            "email (UNIQUE)",
            "password_hash",
            "full_name",
            "avatar_url",
            "avatar_initials",
            "skill_level",
            "games_played",
            "bio",
            "member_since",
            "created_at",
            "updated_at"
          ],
          "relationships": [
            "hosts sessions (one-to-many)",
            "participates in sessions (many-to-many via session_players)"
          ]
        },
        "sessions": {
          "primary_key": "id",
          "foreign_keys": ["host_id (FK to users)"],
          "fields": [
            "sport_type",
            "title",
            "description",
            "date",
            "time_start",
            "time_end",
            "players_needed",
            "visibility",
            "status",
            "latitude",
            "longitude",
            "created_at"
          ],
          "relationships": [
            "has host (many-to-one to users)",
            "has players (many-to-many via session_players)",
            "has booking (one-to-one)",
            "has messages (one-to-many)"
          ]
        },
        "venues": {
          "primary_key": "id",
          "fields": [
            "name",
            "description",
            "address",
            "latitude",
            "longitude",
            "type (INDOOR/OUT)",
            "amenities[]",
            "sports_available",
            "rating",
            "review_count",
            "price_per_hour",
            "operating_hours",
            "contact_phone",
            "photos[]"
          ],
          "relationships": [
            "has venue_slots (one-to-many)",
            "used in bookings (one-to-many)"
          ]
        },
        "session_players": {
          "primary_key": "id",
          "foreign_keys": ["session_id (FK to sessions)", "user_id (FK to users)"],
          "fields": [
            "is_host",
            "status (JOINED/MAYBE/LEFT)",
            "joined_at",
            "payment_status",
            "payment_amount",
            "paid_at"
          ]
        },
        "bookings": {
          "primary_key": "id",
          "foreign_keys": ["session_id (FK to sessions)", "venue_id (FK to venues)"],
          "fields": [
            "date",
            "time_start",
            "time_end",
            "total_cost",
            "cost_per_person",
            "split_payment",
            "status",
            "created_at"
          ]
        },
        "venue_slots": {
          "primary_key": "id",
          "foreign_keys": ["venue_id (FK to venues)", "booking_id (FK to bookings)"],
          "fields": [
            "date",
            "time_start",
            "time_end",
            "is_available"
          ]
        },
        "payments": {
          "primary_key": "id",
          "foreign_keys": ["booking_id (FK to bookings)", "user_id (FK to users)"],
          "fields": [
            "amount",
            "currency",
            "stripe_payment_id",
            "status",
            "created_at"
          ]
        },
        "messages": {
          "primary_key": "id",
          "foreign_keys": ["session_id (FK to sessions)", "sender_id (FK to users)"],
          "fields": [
            "text",
            "is_system",
            "created_at"
          ]
        },
        "notifications": {
          "primary_key": "id",
          "foreign_keys": ["user_id (FK to users)"],
          "fields": [
            "type",
            "icon",
            "title",
            "body",
            "action_type",
            "action_url",
            "is_read",
            "created_at"
          ]
        },
        "reports": {
          "primary_key": "id",
          "foreign_keys": ["reporter_id (FK to users)", "reported_user_id (FK to users)", "session_id (FK to sessions)"],
          "fields": [
            "reason_id",
            "description",
            "status",
            "created_at",
            "resolved_at"
          ]
        },
        "devices": {
          "primary_key": "id",
          "foreign_keys": ["user_id (FK to users)"],
          "fields": [
            "device_token",
            "platform",
            "app_version",
            "created_at",
            "updated_at"
          ]
        },
        "refresh_tokens": {
          "primary_key": "id",
          "foreign_keys": ["user_id (FK to users)"],
          "fields": [
            "token_hash",
            "expires_at",
            "created_at"
          ]
        },
        "session_invites": {
          "primary_key": "id",
          "foreign_keys": ["session_id (FK to sessions)", "inviter_id (FK to users)", "invitee_id (FK to users)"],
          "fields": [
            "message",
            "status",
            "created_at"
          ]
        },
        "notification_prefs": {
          "primary_key": "user_id (FK to users)",
          "fields": [
            "push_enabled",
            "session_invites",
            "player_joined",
            "chat_messages",
            "payment_reminders",
            "session_reminders",
            "marketing"
          ]
        },
        "sport_types": {
          "primary_key": "id",
          "fields": [
            "name",
            "icon",
            "default_players"
          ]
        },
        "payment_methods": {
          "primary_key": "id",
          "foreign_keys": ["user_id (FK to users)"],
          "fields": [
            "stripe_pm_id",
            "type",
            "last4",
            "brand",
            "exp_month",
            "exp_year",
            "is_default"
          ]
        }
      },
      "enum_definitions": {
        "session_status": ["pending", "open", "booked", "completed", "cancelled"],
        "player_status": ["joined", "maybe", "left"],
        "payment_status": ["pending", "processing", "success", "failed", "refunded"],
        "booking_status": ["pending", "confirmed", "cancelled", "completed"],
        "skill_level": ["Beginner", "Intermediate", "Advanced", "All levels"],
        "venue_type": ["Indoor", "Outdoor"],
        "report_status": ["submitted", "under_review", "resolved", "dismissed"],
        "visibility_type": ["public", "private"],
        "notification_type": [
          "session_invite",
          "player_joined",
          "player_left",
          "booking_confirmed",
          "payment_reminder",
          "payment_received",
          "session_reminder",
          "slot_opened",
          "chat_message",
          "session_cancelled",
          "report_update"
        ]
      }
    },
    "system_architecture": {
      "overview": "Three-tier reactive architecture with Spring WebFlux",
      "layers": {
        "controller_layer": {
          "description": "API endpoints handling HTTP requests",
          "controllers": [
            "AuthController",
            "SessionController",
            "BookingController",
            "ChatController",
            "ProfileController",
            "VenueController",
            "NotificationController",
            "ReportController",
            "MapController"
          ]
        },
        "service_layer": {
          "description": "Business logic and orchestration",
          "services": [
            "AuthService",
            "SessionService",
            "BookingService",
            "ChatService",
            "UserService",
            "VenueService",
            "NotificationService",
            "ReportService",
            "PaymentService",
            "GeoService",
            "AutoMatchService"
          ]
        },
        "repository_layer": {
          "description": "Data access using R2DBC",
          "repositories": [
            "UserRepository",
            "SessionRepository",
            "BookingRepository",
            "MessageRepository",
            "VenueRepository",
            "PaymentRepository",
            "NotificationRepository",
            "ReportRepository",
            "DeviceRepository",
            "InviteRepository"
          ]
        }
      },
      "external_services": {
        "postgresql": "Primary database with R2DBC",
        "redis": "Cache and Pub/Sub for real-time events",
        "stripe": "Payment processing",
        "fcm_apns": "Push notifications",
        "sendgrid": "Email service"
      }
    },
    "api_specifications": {
      "authentication": {
        "base_path": "/api/v1/auth",
        "endpoints": [
          {
            "path": "/login",
            "method": "POST",
            "controller": "AuthController",
            "service_method": "authenticate(email, password)",
            "repository": "UserRepository.findByEmail",
            "description": "Returns JWT access + refresh tokens"
          },
          {
            "path": "/register",
            "method": "POST",
            "controller": "AuthController",
            "service_method": "register(RegisterDTO)",
            "repository": "UserRepository.save",
            "description": "Validates email uniqueness"
          },
          {
            "path": "/logout",
            "method": "POST",
            "controller": "AuthController",
            "service_method": "logout(refreshToken)",
            "repository": "RefreshTokenRepository.delete",
            "description": "Invalidates refresh token"
          },
          {
            "path": "/forgot-password",
            "method": "POST",
            "controller": "AuthController",
            "service_method": "forgotPassword(email)",
            "repository": "UserRepository.findByEmail",
            "description": "Sends email via SendGrid"
          },
          {
            "path": "/refresh-token",
            "method": "POST",
            "controller": "AuthController",
            "service_method": "refreshToken(token)",
            "repository": "RefreshTokenRepository.findByToken",
            "description": "Issues new access token"
          }
        ]
      },
      "session_management": {
        "base_path": "/api/v1/sessions",
        "endpoints": [
          {
            "path": "/nearby",
            "method": "GET",
            "controller": "SessionController",
            "service_method": "findNearby(lat, lng, radius, sport)",
            "validation": "Requires location",
            "description": "Find sessions near location"
          },
          {
            "path": "/search",
            "method": "GET",
            "controller": "SessionController",
            "service_method": "search(query, filters)",
            "validation": "Optional filters",
            "description": "Search sessions with filters"
          },
          {
            "path": "/",
            "method": "POST",
            "controller": "SessionController",
            "service_method": "createSession(CreateSessionDTO)",
            "validation": "Auth required, validates sport/time",
            "description": "Create new session"
          },
          {
            "path": "/{id}",
            "method": "GET",
            "controller": "SessionController",
            "service_method": "getSessionDetail(id, userId)",
            "validation": "Returns player list, host info",
            "description": "Get session details"
          },
          {
            "path": "/{id}/join",
            "method": "POST",
            "controller": "SessionController",
            "service_method": "joinSession(id, userId)",
            "validation": "Not full, not already joined",
            "description": "Join a session"
          },
          {
            "path": "/{id}/leave",
            "method": "POST",
            "controller": "SessionController",
            "service_method": "leaveSession(id, userId)",
            "validation": "Must be joined, not host",
            "description": "Leave a session"
          },
          {
            "path": "/{id}/maybe",
            "method": "POST",
            "controller": "SessionController",
            "service_method": "markMaybe(id, userId)",
            "validation": "Updates player status",
            "description": "Mark maybe for session"
          },
          {
            "path": "/{id}/lock",
            "method": "POST",
            "controller": "SessionController",
            "service_method": "lockSession(id, hostId)",
            "validation": "Host only, has joined players",
            "description": "Lock session for booking"
          }
        ]
      },
      "venue_booking": {
        "base_path": "/api/v1/venues",
        "endpoints": [
          {
            "path": "/",
            "method": "GET",
            "controller": "VenueController",
            "service_method": "findNearby(lat, lng, sport, playerCount)",
            "business_logic": "Filters by sport, calculates price/person",
            "description": "Find venues near location"
          },
          {
            "path": "/{id}",
            "method": "GET",
            "controller": "VenueController",
            "service_method": "getVenueDetail(id)",
            "business_logic": "Full venue info, amenities",
            "description": "Get venue details"
          },
          {
            "path": "/{id}/slots",
            "method": "GET",
            "controller": "VenueController",
            "service_method": "getAvailableSlots(id, date)",
            "business_logic": "Real-time availability check",
            "description": "Get available time slots"
          }
        ]
      },
      "booking_management": {
        "base_path": "/api/v1/bookings",
        "endpoints": [
          {
            "path": "/",
            "method": "POST",
            "controller": "BookingController",
            "service_method": "createBooking(CreateBookingDTO)",
            "business_logic": "Validates slot, calculates split",
            "description": "Create booking"
          },
          {
            "path": "/{id}",
            "method": "GET",
            "controller": "BookingController",
            "service_method": "getBookingDetail(id)",
            "business_logic": "Payment status per player",
            "description": "Get booking details"
          },
          {
            "path": "/{id}/confirm",
            "method": "POST",
            "controller": "BookingController",
            "service_method": "confirmBooking(id)",
            "business_logic": "Reserves slot, triggers payments",
            "description": "Confirm booking"
          },
          {
            "path": "/{id}/cancel",
            "method": "POST",
            "controller": "BookingController",
            "service_method": "cancelBooking(id, reason)",
            "business_logic": "Refund logic if applicable",
            "description": "Cancel booking"
          },
          {
            "path": "/{id}/payment-status",
            "method": "GET",
            "controller": "BookingController",
            "service_method": "getPaymentStatus(id)",
            "business_logic": "X of Y paid",
            "description": "Get payment status"
          }
        ]
      },
      "chat": {
        "base_path": "/api/v1/sessions/{id}/chat",
        "endpoints": [
          {
            "path": "/messages",
            "method": "GET",
            "controller": "ChatController",
            "service_method": "getMessages(sessionId, page, size)",
            "real_time": "Paginated history",
            "description": "Get chat messages"
          },
          {
            "path": "/messages",
            "method": "POST",
            "controller": "ChatController",
            "service_method": "sendMessage(sessionId, text)",
            "real_time": "Also broadcasts via WebSocket",
            "description": "Send chat message"
          },
          {
            "path": "/ws/session/{id}",
            "method": "WebSocket",
            "controller": "ChatWebSocketHandler",
            "service_method": "handleMessage()",
            "real_time": "Real-time bidirectional",
            "description": "WebSocket connection for real-time chat"
          }
        ]
      },
      "profile_notifications": {
        "base_path": "/api/v1/users",
        "endpoints": [
          {
            "path": "/me",
            "method": "GET",
            "controller": "ProfileController",
            "service_method": "getCurrentUser()",
            "description": "Get current user profile"
          },
          {
            "path": "/me",
            "method": "PUT",
            "controller": "ProfileController",
            "service_method": "updateProfile(UpdateProfileDTO)",
            "description": "Update user profile"
          },
          {
            "path": "/{id}",
            "method": "GET",
            "controller": "ProfileController",
            "service_method": "getUserProfile(id)",
            "description": "Get user profile by ID"
          },
          {
            "path": "/{id}/stats",
            "method": "GET",
            "controller": "ProfileController",
            "service_method": "getUserStats(id)",
            "description": "Get user statistics"
          },
          {
            "path": "/{id}/history",
            "method": "GET",
            "controller": "ProfileController",
            "service_method": "getMatchHistory(id)",
            "description": "Get user match history"
          }
        ]
      },
      "notification_management": {
        "base_path": "/api/v1/notifications",
        "endpoints": [
          {
            "path": "/",
            "method": "GET",
            "controller": "NotificationController",
            "service_method": "getNotifications(page, size)",
            "description": "Get user notifications"
          },
          {
            "path": "/{id}/read",
            "method": "PUT",
            "controller": "NotificationController",
            "service_method": "markAsRead(id)",
            "description": "Mark notification as read"
          },
          {
            "path": "/read-all",
            "method": "PUT",
            "controller": "NotificationController",
            "service_method": "markAllAsRead()",
            "description": "Mark all notifications as read"
          },
          {
            "path": "/device",
            "method": "POST",
            "controller": "NotificationController",
            "service_method": "registerDevice(token, platform)",
            "description": "Register device for push notifications"
          },
          {
            "path": "/settings",
            "method": "GET/PUT",
            "controller": "NotificationController",
            "service_method": "getSettings() / updateSettings()",
            "description": "Get/update notification settings"
          }
        ]
      },
      "reports": {
        "base_path": "/api/v1/reports",
        "endpoints": [
          {
            "path": "/reasons",
            "method": "GET",
            "controller": "ReportController",
            "service_method": "getReportReasons()",
            "description": "Get available report reasons"
          },
          {
            "path": "/",
            "method": "POST",
            "controller": "ReportController",
            "service_method": "submitReport(ReportDTO)",
            "description": "Submit a report"
          }
        ]
      }
    },
    "data_flows": {
      "session_discovery": {
        "description": "Flow for finding nearby sessions",
        "steps": [
          "Client sends GET /sessions/nearby with location parameters",
          "SessionController receives request",
          "SessionService coordinates multiple data sources",
          "GeoService (PostGIS) handles spatial queries",
          "SessionRepository (R2DBC) fetches session data",
          "Redis Cache stores geo query results",
          "Returns Flux<SessionDTO> enriched with player count and distance"
        ]
      },
      "booking_flow": {
        "description": "Critical path for session booking",
        "steps": [
          "Session moves from OPEN to Venue Selection",
          "Host selects venue and time slot",
          "Booking confirmation process begins",
          "Create Booking record (status: PENDING)",
          "Reserve Venue Slot (optimistic lock)",
          "Update Session status to BOOKED",
          "Create Payment records for each player (split)",
          "Send notifications to all joined players",
          "Trigger payment request via Stripe",
          "Stripe webhook handles payment.succeeded events",
          "Update payment status and check if all paid",
          "If all paid: Booking status becomes CONFIRMED"
        ]
      },
      "real_time_chat": {
        "description": "WebSocket-based real-time chat",
        "architecture": "Redis Pub/Sub for message distribution",
        "channels": "session:{sessionId}",
        "message_types": [
          "chat.message",
          "chat.typing",
          "player.joined",
          "player.left",
          "player.maybe",
          "session.locked",
          "session.cancelled",
          "booking.confirmed",
          "payment.updated",
          "payment.reminder"
        ]
      },
      "notification_flow": {
        "description": "Multi-channel notification system",
        "channels": ["In-App WebSocket", "FCM (Android)", "APNs (iOS)"],
        "triggers": [
          {
            "event": "Player joins session",
            "notification": "Host receives 'John joined your Badminton session'"
          },
          {
            "event": "Session locked",
            "notification": "All players: 'Session locked, venue booking started'"
          },
          {
            "event": "Booking confirmed",
            "notification": "All players: 'Court booked at BlueCourt 19:00'"
          },
          {
            "event": "Payment required",
            "notification": "Player: 'Pay $8 for Badminton session'"
          },
          {
            "event": "Payment received",
            "notification": "Host: 'John paid $8 (3/4 paid)'"
          }
        ]
      }
    },
    "security": {
      "jwt_authentication": {
        "flow": "Access token (15 min TTL) + Refresh token (7 day TTL)",
        "components": [
          "AuthController handles login/register",
          "AuthService validates credentials and generates tokens",
          "JWT Filter (WebFilter) validates tokens on subsequent requests",
          "RefreshTokenRepository stores refresh tokens in database"
        ]
      },
      "error_handling": {
        "global_exception_handler": "ControllerAdvice for WebFlux",
        "custom_exceptions": [
          "SessionNotFoundException (404)",
          "SessionFullException (409)",
          "UnauthorizedException (403)",
          "SlotAlreadyBookedException (409)"
        ]
      },
      "concurrency_handling": {
        "optimistic_locking": "Used for venue slot reservation",
        "implementation": "BookingService.confirmBooking with venueSlotRepository.reserveSlotWithLock",
        "error_handling": "Catches OptimisticLockingFailureException"
      }
    },
    "database_performance": {
      "indexes": {
        "geospatial": [
          "idx_sessions_location ON sessions USING GIST (ST_MakePoint(longitude, latitude)::geography)",
          "idx_venues_location ON venues USING GIST (ST_MakePoint(longitude, latitude)::geography)"
        ],
        "session_discovery": [
          "idx_sessions_status_date ON sessions (status, date) WHERE status = 'open'",
          "idx_sessions_sport_status ON sessions (sport_type, status)",
          "idx_sessions_host ON sessions (host_id)"
        ],
        "player_lookups": [
          "idx_session_players_session ON session_players (session_id)",
          "idx_session_players_user ON session_players (user_id)",
          "idx_session_players_session_status ON session_players (session_id, status)"
        ],
        "booking_queries": [
          "idx_bookings_session ON bookings (session_id)",
          "idx_bookings_venue_date ON bookings (venue_id, date)",
          "idx_venue_slots_availability ON venue_slots (venue_id, date, is_available)"
        ],
        "chat_message_ordering": [
          "idx_messages_session_created ON messages (session_id, created_at DESC)"
        ],
        "notification_queries": [
          "idx_notifications_user_read ON notifications (user_id, is_read, created_at DESC)"
        ],
        "auth_indexes": [
          "idx_users_email ON users (email)",
          "idx_refresh_tokens_user ON refresh_tokens (user_id)",
          "idx_devices_user ON devices (user_id)"
        ]
      }
    },
    "configuration": {
      "application_yml_structure": {
        "spring": {
          "r2dbc": {
            "url": "r2dbc:postgresql://${DB_HOST}:5432/${DB_NAME}",
            "username": "${DB_USER}",
            "password": "${DB_PASSWORD}",
            "pool": {
              "initial-size": 10,
              "max-size": 50,
              "max-idle-time": "30m"
            }
          },
          "data": {
            "redis": {
              "host": "${REDIS_HOST}",
              "port": 6379
            }
          },
          "security": {
            "jwt": {
              "secret": "${JWT_SECRET}",
              "access-token-expiration": 900000,
              "refresh-token-expiration": 604800000
            }
          }
        },
        "stripe": {
          "api-key": "${STRIPE_API_KEY}",
          "webhook-secret": "${STRIPE_WEBHOOK_SECRET}"
        },
        "firebase": {
          "credentials-path": "${FIREBASE_CREDENTIALS_PATH}"
        },
        "sendgrid": {
          "api-key": "${SENDGRID_API_KEY}",
          "from-email": "noreply@sportio.app"
        },
        "geo": {
          "default-radius-km": 10,
          "max-radius-km": 50
        }
      }
    },
    "business_rules": [
      {
        "id": "BR-001",
        "description": "Session requires at least 2 players to lock",
        "implementation": "Validate in lockSession()"
      },
      {
        "id": "BR-002",
        "description": "Only host can lock/cancel session",
        "implementation": "Check hostId == currentUserId"
      },
      {
        "id": "BR-003",
        "description": "Cannot join full session",
        "implementation": "Check playerCount < playersNeeded"
      },
      {
        "id": "BR-004",
        "description": "Cannot join same session twice",
        "implementation": "Check existsBySessionIdAndUserId"
      },
      {
        "id": "BR-005",
        "description": "Payment splits equally among players",
        "implementation": "totalCost / playerCount"
      },
      {
        "id": "BR-006",
        "description": "Venue slot can only be booked once",
        "implementation": "Optimistic locking on venue_slots"
      },
      {
        "id": "BR-007",
        "description": "Session auto-cancels if no payments in 24h",
        "implementation": "Scheduled job"
      },
      {
        "id": "BR-008",
        "description": "Past sessions cannot be joined",
        "implementation": "Check session.date >= today"
      },
      {
        "id": "BR-009",
        "description": "Host cannot leave, only cancel",
        "implementation": "Block leave for host, show cancel option"
      },
      {
        "id": "BR-010",
        "description": "Report requires reason selection",
        "implementation": "Validate reasonId != null"
      }
    ]
  }
}